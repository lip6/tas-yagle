<?xml version="1.0" encoding="ISO-8859-1" ?>
<section niv='2'><title>VHDL - Generated Behavior</title>
<section niv='3'><title>Description</title>

<p>The VHDL which is automatically generated by &tool; is an RTL level zero delay data-flow description. It contains a list of concurrent assignment statements which represent the behavior of the simple gates which are neither high impedance nor conflictual. Distinct VHDL process blocks are used to describe those gates which represent identified memory elements as well as those gates for which &tool; was unable to verify the duality.</p>
<p>The declarations within the VHDL file conform to those of the IEEE STD_LOGIC package. This makes the VHDL readily exploitable by most commercial simulation, formal proof and synthesis tools.</p>
<p>The VHDL produced if FCL is used remains similar since a given behavioral description is parsed to generate an internal behavioral model, however this model can contain delay information, specified through the use of the AFTER attribute. However, if the full hierarchical pattern recognition is used, then any kind of behavioral description can be produced. Here we can only describe the VHDL which is automatically generated.</p>
</section>
<section niv='3'><title>Latches and Registers</title>

<p>Latches and registers are described using separate VHDL processes, to allow easy latch inference by any subsequent parser. A cascaded "IF ... THEN ... ELSIF ... ... END IF" statement is used to represent separate driving conditions. For example a latch with two clocks would be represented by :</p>
<code>
<cl>REG1: PROCESS (ck1,ck2)</cl>
<cl>BEGIN</cl>
<cl>  IF ck1 = '1' THEN</cl>
<cl>    latch &lt;= data1;</cl>
<cl>  ELSIF ck2 = '1' THEN</cl>
<cl>    latch &lt;= data2;</cl>
<cl>  END IF;</cl>
<cl>END PROCESS;</cl>
</code>
<p>It should be noted that the lexical construction guarantees that the latch is not conflictual, and that the memory signal is incompletely assigned. This allows straightforward latch inference.</p>
<p>Registers are differentiated from latches through the use of the EVENT attribute on one (and only one) of the clock signals. For example, a positive-edge triggered flip-flop with an asynchronous reset would be represented by :</p>
<code>
<cl>REG1: PROCESS (ck,reset)</cl>
<cl>BEGIN</cl>
<cl>  IF reset = '1' THEN</cl>
<cl>    reg &lt;= '0';</cl>
<cl>  ELSIF (ck = '1' and ck'EVENT) THEN</cl>
<cl>    reg &lt;= data;</cl>
<cl>  END IF;</cl>
<cl>END PROCESS;</cl>
</code>

</section>
<section niv='3'><title>High impedance or Conflictual Nodes</title>

<p>Both high impedance and conflictual nodes are modeled by two process blocks. One process describes the condition for the assignment of logic '1', whilst the other describes the condition for the assignment of logic '0'. For example a simple tri-state gate would be described as follows :</p>
<code>
<cl>BUS0: PROCESS (enable,data)</cl>
<cl>BEGIN</cl>
<cl>  IF (enable = '1' and data = '1') THEN</cl>
<cl>    out &lt;= '1';</cl>
<cl>  ELSE</cl>
<cl>    out &lt;= 'Z';</cl>
<cl>  END IF;</cl>
<cl>END PROCESS;</cl>
<cl> </cl>
<cl>BUS1: PROCESS (enable, data)</cl>
<cl>BEGIN</cl>
<cl>  IF (enable = '1' and data = '0') THEN</cl>
<cl>    out &lt;= '0';</cl>
<cl>  ELSE</cl>
<cl>    out &lt;= 'Z';</cl>
<cl>  END IF;</cl>
<cl>END PROCESS;</cl>
</code>
<p>The "IF ... THEN ... ELSE ... END IF" configuration is used to ensure that the tri-state signal is completely defined. This is necessary to avoid the tri-state node being mistaken for a latch.</p>
</section>
<pagebreak/>
<section niv='3'><title>Vectorization</title>

<p>No additional vectorization is deduced by &tool;. Connector and signal declarations can be optionally vectorized or devectorized. All assignment expressions are given on a bit by bit basis.</p>

</section>
<section niv='3'><title>Example</title>

<p>The following example of a VHDL file generated by &tool; illustrates the typical structure :</p>
<smallcode>
<cl>-- VHDL data flow description generated from `addaccu`</cl>
<cl>--		date : Tue Jul 18 20:08:28 2000</cl>
<cl> </cl>
<cl>library IEEE;</cl>
<cl>use IEEE.std_logic_1164.all;</cl>
<cl> </cl>
<cl>-- Entity Declaration</cl>
<cl> </cl>
<cl>ENTITY addaccu IS</cl>
<cl>  PORT (</cl>
<cl>  a : in std_logic_vector (3 DOWNTO 0);</cl>
<cl>  b : in std_logic_vector (3 DOWNTO 0);</cl>
<cl>  ck : in std_logic;</cl>
<cl>  s : inout std_logic_vector (3 DOWNTO 0);</cl>
<cl>  sel : in std_logic;</cl>
<cl>  vdd : in std_logic;</cl>
<cl>  vss : in std_logic</cl>
<cl>  );</cl>
<cl>END addaccu;</cl>
<cl> </cl>
<cl>-- Architecture Declaration</cl>
<cl> </cl>
<cl>ARCHITECTURE RTL OF addaccu IS</cl>
<cl>  SIGNAL accu : STD_LOGIC_VECTOR (3 DOWNTO 0);</cl>
<cl>  SIGNAL oper : STD_LOGIC_VECTOR (3 DOWNTO 0);</cl>
<cl>  SIGNAL carry : STD_LOGIC_VECTOR (2 DOWNTO 1);</cl>
<cl> </cl>
<cl>BEGIN</cl>
<cl>  carry (1) &lt;= ((oper (1) and ((oper (0) and (a (1) or a (0))) or a (1))) or</cl>
<cl>(oper (0) and a (1) and a (0)));</cl>
<cl>  carry (2) &lt;= ((a (2) and (carry (1) or oper (2))) or (carry (1) and oper (2)));</cl>
<cl>  oper (0) &lt;= ((b (0) and (accu (0) or not (sel))) or (accu (0) and sel));</cl>
<cl>  oper (1) &lt;= ((b (1) and (accu (1) or not (sel))) or (accu (1) and sel));</cl>
<cl>  oper (2) &lt;= ((b (2) and (accu (2) or not (sel))) or (accu (2) and sel));</cl>
<cl>  oper (3) &lt;= ((b (3) and (accu (3) or not (sel))) or (accu (3) and sel));</cl>
<cl> </cl>
<cl>REG0: PROCESS (ck)</cl>
<cl>BEGIN</cl>
<cl>  IF (ck = '0' and ck'EVENT) THEN</cl>
<cl>    accu (0) &lt;= s (0);</cl>
<cl>  END IF;</cl>
<cl>END PROCESS;</cl>
<cl> </cl>
<cl>REG1: PROCESS (ck)</cl>
<cl>BEGIN</cl>
<cl>  IF (ck = '0' and ck'EVENT) THEN</cl>
<cl>    accu (1) &lt;= s (1);</cl>
<cl>  END IF;</cl>
<cl>END PROCESS;</cl>
<cl> </cl>
<cl>REG2: PROCESS (ck)</cl>
<cl>BEGIN</cl>
<cl>  IF (ck = '0' and ck'EVENT) THEN</cl>
<cl>    accu (2) &lt;= s (2);</cl>
<cl>  END IF;</cl>
<cl>END PROCESS;</cl>
<cl> </cl>
<cl>REG3: PROCESS (ck)</cl>
<cl>BEGIN</cl>
<cl>  IF (ck = '0' and ck'EVENT) THEN</cl>
<cl>    accu (3) &lt;= s (3);</cl>
<cl>  END IF;</cl>
<cl>END PROCESS;</cl>
<cl> </cl>
<cl>  s (0) &lt;= not ((a (0) xor oper (0)));</cl>
<cl> </cl>
<cl>  s (1) &lt;= (a (1) xor oper (1) xor (not (oper (0)) or not (a (0))));</cl>
<cl> </cl>
<cl>  s (2) &lt;= (a (2) xor oper (2) xor not (carry (1)));</cl>
<cl> </cl>
<cl>  s (3) &lt;= (a (3) xor oper (3) xor not (carry (2)));</cl>
<cl> </cl>
<cl>END;</cl>
</smallcode>
</section>
</section>
