<?xml version="1.0" encoding="ISO-8859-1" ?>
<chapter>
<section niv='1'><title>Timing DB Construction</title>

&file_loading;

<section niv='2'><title>DB Construction</title>

&power_supplies;

<section niv='3'><title>Defining Simulation Thresholds</title>
<p>By default, the slope is defined between 20% and 80% of Vdd. It is possible to change those values with the <f>simVthLow</f> and <f>simVthHigh</f> variables. Delays are always computed with a threshold of 50%.</p>
</section>

<section niv='3'><title>Defining Simulation Temperature</title>
<p>Temperature can be deined either with the <f>simTemperature</f> configuration variable or through a <f>.TEMP</f> statement in the Spice file.</p>
</section>

<section niv='3'><title>Invoking DB Construction</title>
<p>The timing DB construction routine are invoked by the
<f>hitas</f> command, which takes as argument the name of a sub-circuit. The sub-circuit must be among the previously loaded netlists. If the sub-circuit contains instances it will be flattened to the transistor-level.  In such a case, signal naming respects the hierarchical paths. The name of a signal is the concatenation of the names of the successive instances that appear in the hierarchical path leading to the physical node the signalis associated with. 

The typical Tcl command for invoking timing DB construction is:</p>
<code>set fig [hitas my_design]</code>
<p>where <f>my_design</f> is the name of the <f>.SUBCKT</f> to treat. If flatten is impossible (i.e. transistor level sub-circuits
are missing for leaf cells), with no further configuration, the tool will issue an error and exit.</p>
<p>The default configuration creates a timing DB containing DTX, STM, RCX files.</p> 
</section>

</section>

<section niv='2'><title>Output Files</title>

<section niv='3'><title>REP file</title>
<p>Once the Timing DB has been constructed, it is important to have a look at the <f>.rep</f> file. This file is a report
of the disassembly process. The essential thing to check here is that latches have been correctly detected. Ideally,
all the latches have been automatically detected by the Boolean analysis of the gate loops. However, the report file 
lists all the loops between gates that have been identified during the disassembly process, and if they have been 
associated with a latch. A complete list of the warnings issued in the <f>.rep</f> is available in the reference manual.</p>
</section>

<section niv='3'><title>LOOP file</title>
<p>Ideally the <f>.loop</f> file does not exist, as it is created only
if the path searching algorithm detects combinational loops in the design. Note that the path searching algorithm 
is performed after the disassembly process, and therefore the occurrence of combinational loops is heavily dependant on
the correct recognition of the latches in the design.</p>
</section>

<section niv='3'><title>CNS, CNV files</title>
<p>The <f>.cns</f> file describes the partitions (cones), and their interconnections, resulting from the disassembly process. 
This file is very useful for debugging purposes, and necessary for the spice deck generation of timing paths. The
file can be generated with the following configuration:</p>
<code>
<cl>avt_config tasGenerateConeFile yes</cl>
</code>
<p>The <f>.cns</f> file is intented to be re-read by &tool; and therefore is not very human-readable. A more friendly
version can be generated by setting:</p> 
<code>
<cl>avt_config avtVerboseConeFile yes</cl>
</code>
</section>

<section niv='3'><title>DTX and STM files</title>
<p>The default configuration generates the <f>.dtx</f> file (timing arcs) and <f>.stm</f> file /9timing models).</p>

</section>
</section>


<section niv='2'><title>Latch Detection and Modeling</title>

<p>&tool; handles the following types of latches:</p>
<list>
<item>D-latches</item> 
<item>Symmetric latches and memory cells</item>
<item>RS latches</item> 
<item>Dynamic latches</item>
</list>

<p>All those types of latches are recognized and modeled automatically during the partitioning phase. If automatic detection were to fail, manual identification is still possible. User-defined tags may be applied on nodes in the design.</p>

<section niv='3'><title>Detection Sequences</title>

<section niv='4'><title>Manual Identification</title>
<p>If latch/command tags on specific nodes are set in the configuration file, those tags will be applied and will disable any subsequent automatic analysis upon those nodes.</p>
</section>

<section niv='4'><title>Simple Detection</title>
<p>Simple detection is based upon pattern matching. If activated, this sequence uses simple patterns and rules to quickly detect the simplest latch structures. This sequence is to be used with caution. It permits to quickly detect the most common latches but also uses some heuristics which may not be correct for more complex latches. This sequence is particularly useful (time saving) when dealing with static memories (SRAM) containing a large number of 6T bit-cells. Latches detected at that point will be: </p>
    <list>
    <item>Memory cells, provided they only consist of looped inverters</item>
    <item>Level-holders, looped inverters also</item>
    <item>Simple D-latches. In that case the transistor controlling the memory node will be the one the closer to the memory point</item>
    </list>
</section>
    
<section niv='4'><title>Automatic Detection</title>
<p>Automatic detection is based upon loop analysis. This sequence recognizes any kind of fully static latch designed using an active feedback loop, and containing any number of clock inputs as well as asynchronous set and reset inputs. Within this sequence, specific algorithms may be further applied to model RS latches, asynchronous set and reset within D-latches and symmetric latches.</p>
    <list>
    <item>RS latches. Automatic detection and modelling of NAND/NOR based RS bi-stable</item>
    <item>Asynchronous signals: set and reset detection. D-Latches further modelling </item>
    <item>Symmetric latches</item>
    </list>
</section>

<section niv='4'><title>Dynamic Latches Detection</title>
</section>

</section>

<section niv='3'><title>Enabling Detection Sequences</title>

<p>The detection sequences are controlled by the following variables:</p>

<glossary>
<row><article>Manual Identification</article>
<def><p><f>inf_MarkSignal</f></p>
<p><f>inf_MarkTrans</f></p></def></row>
<row><article>Simple Detection     </article><def><p><f>yagSimpleLatchDetection=memsym|levelhold|latch</f></p></def></row>
<row><article>Automatic Detection  </article><def><f>yagAutomaticLatchDetection=yes</f></def></row>
<row><article>RS Latches </article><def><p><f>yagAutomaticLatchDetection=yes</f></p> 
                                        <p><f>yagAutomaticRSDetection=mark|latch|legal|illegal</f></p></def></row>
<row><article>Asynchronous Signals</article><def><p><f>yagAutomaticLatchDetection=yes</f></p>
                                                 <p><f>yagSetResetDetection=yes|remove</f></p></def></row>
<row><article>Symmetric Latches</article><def><p><f>yagAutomaticLatchDetection=yes</f></p>
                                                 <p><f>yagAutomaticMemsymDetection=yes|remove</f></p></def></row>
<row><article>Dynamic Latches</article><def><f>yagDynamicLatchDetection=yes</f></def></row>
</glossary>

<p>See &tool; Reference Guide for a more detailed description of those configuration variables.</p>
</section>
</section>

<section niv='2'><title>Static Latch Modeling</title>

<p>Latches such as the one described below are well recognized with the automatic algorithm controlled by <f>yagAutomaticLatchDetection</f>. In this example &tool; recognizes a latch around the node <f>master</f> (and another one around the node <f>slave</f> - for the sake of simplicity we only discuss here the first latch). This node is tagged in the database as a <b>Latch</b> node (see <f>.cnv</f> file). </p>

<imgsize namehtml="latch.gif" namepdf="latch.svg"/>

<p>Each Latch node is controlled by <b>Command</b> transistors. Here the <b>Command</b> transistors for node <f>master</f> are <f>tn0</f> and <f>tp0</f> - they control the writing of the data - and <f>tp1</f> and <f>tp2</f> - they control the reset of the latch.</p>

<section niv='3'><title>Asynchronous Set and Reset</title>

<p>The modeling of static latches can be refined in order to cope with the set and reset signals. This is controlled by <f>yagSetResetDetection</f>, and disabled by default (set to <f>no</f>). Whwn set to <f>yes</f>, the transistor <f>tp1</f> is no longer considered to be a command and <f>tp2</f> is marked <b>Async</b>. This prevents the construction of asynchronous timings arcs between the reset signal and memory node - between <f>RN</f> and <f>master</f> here - which otherwise clutter the reports.</p>

</section>
<section niv='3'><title>Manual Configuration</title>
<p>The following manual configuration would lead to the same modeling as the one generated by the automatic detection. We present it as an example of what should be done in order to model latches which would not be automatically recognized. The following lines describe the configuration to be used for tagging the <f>master</f> <b>Latch</b> node and associated <b>Command</b> transistors.</p> 

<code>
<cl>inf_MarkSignal master Latch+Master</cl>
<cl>inf_MarkTransistor tn0 Command</cl>
<cl>inf_MarkTransistor tp0 Command</cl>
<cl>inf_MarkTransistor tn1 Feedback+NonFunctional</cl>
<cl>inf_MarkTransistor tn2 Feedback+NonFunctional</cl>
<cl>inf_MarkTransistor tn3 Feedback+NonFunctional</cl>
<cl>inf_MarkTransistor tp1 Command+NonFunctional</cl>
<cl>inf_MarkTransistor tp2 Command</cl>
<cl>inf_MarkTransistor tp3 Feedback+NonFunctional</cl>
</code>

<p>&tool; performs latch-based analysis, so the MASTER tag is optional</p>

<p><b>Timing Arcs</b></p>
<p>&tool; constructs the following timing arcs:  </p>

<code>
<cl>DATA: D (R) -> master (F), enabled by ICKN (R)</cl> 
<cl>DATA: D (F) -> master (R), enabled by ICK (F)</cl>
<cl>ACCESS: ICK (F) -> master (R)</cl>
<cl>ACCESS: ICKN (R) -> master (F)</cl>
</code>

</section>
<section niv='3'><title>Intrinsic Setup and Hold</title>

<p>Setup and hold timing checks are performed at the memory node itself - the <f>master</f> node.  For both setup and hold timing checks, &tool; also adds correction margins which further ensure 
the robustness of the analysis. These margins are called intrinsic setup and intrinsic hold times.</p>
 
<code>
<cl>SETUP: master (R) -> ICKN(R) - closing event of the command </cl>
<cl>SETUP: master (F) -> ICK(F)</cl>
<cl>HOLD: master (R) -> ICKN(R) - closing event of the command </cl>
<cl>HOLD: master (F) -> ICK(F)</cl>
</code>

<section niv='4'><title>Intrinsic Setup</title>

<p>For setup, HITAS checks that the latest possible switching time of the memory node - caused by the switching of the data - occurs before the earliest possible closing time of the latch in the next cycle - here the earliest time between ICK rising and ICKN falling - so that the data is always memorized in the next cycle. This reads:</p>

<p><f>D-&gt;mastermax &lt; min(CK-&gt;ICKNmin, CK-&gt;ICKmin) + cycle_time</f></p>

<p>The setup slack is then defined as:</p>

<p><f>Setup_slack = min(CK-&gt;ICKNmin, CK-&gt;ICKmin) + cycle_time - D-&gt;mastermax</f></p>

<p>Or in a simpler way:</p>

<p><f>Setup_slack = clock_path_min + cycle_time - data_path_max</f></p>

<p>In fact, &tool; does not calculate the latest possible switching time of the memory node, but the latest possible switching time of the feedback node, further ensuring that the data has been properly stored in the latch. This gives:</p>

<p><f>D-&gt;mastermax + master-&gt;feedback &lt; min(CK-&gt;ICKNmin, CK-&gt;ICKmin) + cycle_time</f></p>

<p>The setup slack is then defined as:</p>

<p><f>Setup_slack = min(CK-&gt;ICKNmin, CK-&gt;ICKmin) + cycle_time - D-&gt;mastermax - master-&gt;feedback</f></p>

<p>Or in a simpler way:</p>

<p><f>Setup_slack = clock_path_min + cycle_time - data_path_max - intrinsic_setup</f></p>

<p>From a modeling point of view, this translates to the addition of a setup timing arc, between the memory node and each of the signals driving a gate of a command transistor, whose value is the propagation delay between the memory node and the feedback node.  </p>

</section>
<section niv='4'><title>Intrinsic Hold</title>

<p>For hold, &tool; checks that the earliest possible switching time of the memory node - caused by the switching of the data -  occurs after the latest possible closing time of the latch in the same cycle - here the latest time between ICK rising and ICKN falling - so that no other data is accidentally memorized in the same cycle. </p> 

<p><f>D-&gt;mastermin &gt; max(CK-&gt;ICKNmax, CK-&gt;ICKmax)</f></p>

<p>The hold slack is defined as:</p>

<p><f>Hold_slack = D-&gt;mastermin - max(CK-&gt;ICKNmax, CK-&gt;ICKmax)</f></p>

<p>Or in a simpler way:</p>

<p><f>Hold_slack = data_path_min - clock_path_max</f></p>

<p>Actually, &tool; does estimates latest possible closing time of the latch not at Vdd/2, as it is done for all other propagation delays, but at the Vt of the Command transistors. This assumes that the data may still be stored, even if the Command transistors are in a low-conducting mode. Preventing this adds robustness to the analysis. </p>

<p><f>D-&gt;mastermin &gt; max(CK-&gt;ICKNmax, CK-&gt;ICKmax) + max(slopeICKN vdd/2-&gt;vt, slopeICK vdd/2-&gt;vt)</f></p>

<p>The hold slack is defined as:</p>

<p><f>Hold_slack = D-&gt;mastermin - max(CK-&gt;ICKNmax, CK-&gt;ICKmax) - max(slopeICKN vdd/2-&gt;vt, slopeICK vdd/2-&gt;vt)</f></p>

<p>Or in a simpler way:</p>

<p><f>Hold_slack = data_path_min - clock_path_max - intrinsic_hold</f></p>

<p>From a modeling point of view, this translates in the addition of a hold timing arc, between the memory node and each of the signals driving a gate of a Command transistor, which value is the portion between Vdd/2 and Vt of the slope on the signal driving the gate.  </p>

</section>
</section>
</section>

<section niv='2'><title>RS-Latches</title>

<p>&tool; automatically recognizes and models NAND-based and NOR-based RS structures. Only the RS structures where NAND or NOR building gates directly loop on each other (with no intermediary inverter or buffer present) are automatically recognized. 
However, manual recognition is still possible, and the same range of modeling methods can be applied on manually-defined RS structures.</p>

<p>Automatic recognition of RS structures is enabled by switching on the variable <f>yagAutomaticRSDetection</f>:</p>

<code>
<cl>avt_config yagAutomaticRSDetection mark</cl>
</code>

<p>This enables &tool; to detect NAND-based and NOR-based RS structures 
having an arbitrary number of inputs, providing that the constituent NAND or NOR  gates loop directly onto each other. Below is an example of such a structure.</p>
<imgsize namehtml="NOR.gif" namepdf="NOR.svg"/>
 
<p>With this configuration, &tool; only marks the looping nodes as <f>RS</f> (see <f>.cnv</f> file), and issues a message in the <f>.rep</f> file. For this NOR-based RS structure, the following timing arcs 
are then created:</p>

<code>
<cl>S (rising) to QB (falling)</cl>
<cl>S (falling) to QB (rising)</cl>
<cl>R (rising) to Q (falling)</cl>
<cl>R (falling) to Q (rising)</cl>
<cl>Q (rising) to QB (falling)</cl>
<cl>Q (falling) to QB (rising)</cl>
<cl>QB (rising) to Q (falling)</cl>
<cl>QB (falling) to Q (rising)</cl>
</code>

<p>This leads to combinational loops the tool is not able to handle, for example:</p>
<code>
<cl>S (rising) to QB (falling) to Q (rising) to QB (falling) to ...</cl>
</code>

<p>The study of the truth tables of the NOR gate tells us that such loops actually cannot occur, as some transitions cannot be excited. We will detail this in the next section. Regarding NAND-based RS structures, here is an example of what &tool; properly detects:</p>
 
<imgsize namehtml="NAND.gif" namepdf="NAND.svg"/>

<p>Here, the created timing arcs are the following ones:</p>

<code>
<cl>S (rising) to Q (falling)</cl>
<cl>S (falling) to Q (rising)</cl>
<cl>R (rising) to QB (falling)</cl>
<cl>R (falling) to QB (rising)</cl>
<cl>Q (rising) to QB (falling)</cl>
<cl>Q (falling) to QB (rising)</cl>
<cl>QB (rising) to Q (falling)</cl>
<cl>QB (falling) to Q (rising)</cl>
</code>

<p>They also lead to combinational loops.</p>

<section niv='3'><title>Modeling of NOR-based structures</title>
<section niv='4'><title>All States Allowed</title>
<p>Let's study the truth table of the NOR-based design:</p>

<imgsize namehtml="NORTAB.gif" namepdf="NORTAB.svg"/>
<p>Let's consider the timing arcs from Q to QB. As stated above, we have the following timing arcs, which we can also identify from the truth table:</p>

<code>
<cl>Q (rising) to QB (falling)</cl>
<cl>Q (falling) to QB (rising)</cl>
<cl>QB (rising) to Q (falling)</cl>
<cl>QB (falling) to Q (rising)</cl>
</code>

<p>Now we must keep in mind that we are dealing with NOR gates, and that a NOR propagates a transition from one of its inputs only if the others inputs are all <f>0</f>. In a situation where NOR gates are looped on each others, some transitions cannot be excited. If we look at the truth table above, we see that the only way to have <f>Q (rising)</f> is to perform the set operation, where 
<f>S</f> is <f>1</f> and <f>R</f> is <f>0</f>. But if <f>S</f> is now <f>1</f>, no transition can propagate through the NOR gate: <f>Q 
(rising) to QB (falling)</f> can never be excited. </p>
<p>We have the symmetrical situation for <f>QB (rising) to Q (falling)</f> in the reset operation. The following timing arcs finally remain, and prevent the occurrence of combinational loops: </p>
 
<code>
<cl>S (rising) to QB (falling)</cl>
<cl>S (falling) to QB (rising)</cl>
<cl>R (rising) to Q (falling)</cl>
<cl>R (falling) to Q (rising)</cl>
<cl>Q (falling) to QB (rising)</cl>
<cl>QB (falling) to Q (rising)</cl>
</code>

<p>This way of modeling is enabled by switching the yagAutomaticRSDetection to 
<f>"mark+illegal"</f>:</p>
<code>
<cl>avt_config  yagAutomaticRSDetection "mark+illegal"</cl>
</code>
</section>

<section niv='4'><title>Legal States Only</title>

<p>The configuration described above only removes timing arcs that can never be excited. It allows timing arcs used when entering an illegal state: when both <f>S</f> and <f>R</f> are set to <f>1</f>, <f>Q</f> and <f>QB</f> are both <f>0</f>. It is the only situation where the NOR gate can have its <f>R</f> (resp. <f>S</f>) input set to <f>1</f> and its <f>Q</f> (resp. <f>QB</f>) input is set to <f>0</f>, and thus propagate a falling transition from <f>R</f> or <f>S</f>:</p>

<code>
<cl>S (falling) to QB (rising)</cl>
<cl>R (falling) to Q (rising)</cl>
</code>

<p>Depending on the surrounding logic of the RS structure, this situation may or may not occur. 
However, the tool is not able to analyze it. If you desire to consider RS structures always 
remaining in the legal state, you should state it explicitly:</p>

<code>
<cl>avt_config  yagAutomaticRSDetection "mark+legal"</cl>
</code>

<p>Only the following transitions remain:</p>

<code>
<cl>S (rising) to QB (falling)</cl>
<cl>R (rising) to Q (falling)</cl>
<cl>Q (falling) to QB (rising)</cl>
<cl>QB (falling) to Q (rising)</cl>
</code>

</section>
</section>

<section niv='3'><title>Modeling of NAND-based structures</title>
<section niv='4'><title>All States Allowed</title>
<p>The same reasoning applies for a NAND-based structure, based on its truth table:</p>

<imgsize namehtml="NANDTAB.gif" namepdf="NANDTAB.svg"/>

<p>The NAND gate propagates a transition from one of its inputs only if the other inputs are all 
<f>1</f>. Removing the unexcited timing arcs leads to the following arcs remaining:</p>

<code>
<cl>S (rising) to Q (falling)</cl>
<cl>S (falling) to Q (rising)</cl>
<cl>R (rising) to QB (falling)</cl>
<cl>R (falling) to QB (rising)</cl>
<cl>Q (rising) to QB (falling)</cl>
<cl>QB (rising) to Q (falling)</cl>
</code>
</section>
<section niv='4'><title>Legal States Only</title>
<p>If only legal states are allowed, the following timing arcs remain:</p>

<code>
<cl>S (rising) to Q (falling)</cl>
<cl>R (rising) to QB (falling)</cl>
<cl>Q (rising) to QB (falling)</cl>
<cl>QB (rising) to Q (falling)</cl>
</code>
</section>
</section>
<section niv='3'><title>Fine Tuning</title>
<p>The <f>yagAutomaticRSDetection</f> variable defines a global behavior for all the RS structures encountered and properly detected. However, one may wish to define a specific behavior for a given RS structure encountered. For example, on 100 RS structures in a design, 94 may be treated as always remaining in legal state, 4 may be treated as possibly entering an illegal state, and the 2 remaining ones may be treated as pulse generators. One should then wish to 
override a global configuration for given RS structures. It is therefore possible in &tool; with the <f>inf_DefineRS</f> Tcl command, as done in the following script, referring to the example 
above:</p>

<code>
<cl>avt_config yagAutomaticRSDetection "mark+legal"</cl>
<cl>inf_DefineRS nand1.S illegal  </cl>
<cl>inf_DefineRS nand2.S illegal  </cl>
<cl>inf_DefineRS nand3.S illegal  </cl>
<cl>inf_DefineRS nand4.S illegal  </cl>
<cl>inf_DefineRS pulsegen1.S mark_only  </cl>
<cl>inf_DefineRS pulsegen2.S mark_only  </cl>
</code>
</section>
<section niv='3'><title>Manual Tuning</title>

<p>Situations arise where timing arcs should be removed manually: when RS structures are not automatically detected, and when they are used for purposes not covered by the modeling options described above (typically in pulse generators).</p>

<p>When RS structures are not properly detected, timing arcs should be removed in the same way they are removed when automatically handled. Arc removal should be done with inf_DisableTimingArc Tcl function. The following script describes manual removal of timing arcs for the NOR-based RS latch described above, in the "Legal States Only" situation:</p>

<code>
<cl>inf_DisableTimingArc S QB du</cl>
<cl>inf_DisableTimingArc R Q du</cl>
<cl>inf_DisableTimingArc Q QB ud</cl>
<cl>inf_DisableTimingArc QB Q ud</cl>
</code>

</section>
</section>

<section niv='2'><title>Symmetric Latches</title>
<p>&tool; considers latches symmetric when it is possible to write on both sides of the memorizing loop. Latches which fall into this category are symmetric pulldowns, symmetric bitcells and asymmetric pulldowns, as described below.</p>
<imgsize namehtml="Sym_latches.gif" namepdf="Sym_latches.svg"/>
<p> &tool; considers both sides - <f>m</f> and <f>mb</f> of the symmetric latc being <b>Latch</b> nodes. A supplementary <b>Memsym</b> tag is added on each <b>Latch</b> node. Timing checks - setup and hold - are performed on both sides of the symmetric latch.</p>
<p>Intrinsic setup and hold times are added on each <b>Latch</b> node in the same way as they are on a D-Latch <b>Latch</b> node. The next sections detail modeling of symmetric latches</p>
<section niv='3'><title>Symmetric Pulldown</title>
<section niv='4'><title>Typical Structure</title>
<imgsize namehtml="Sym_pulldown.gif" namepdf="Sym_pulldown.svg"/>
</section>

<section niv='4'><title>Latch Nodes and Commands</title>
<p>The latch nodes are here <f>m</f> and <f>mb</f>. The <b>Command</b> transistors are the ones which gate is controlled by <b>ck</b>.</p>
</section>

<section niv='4'><title>Timing Arcs</title>
<p>Timing arcs are the following:</p>

<code>
<cl>DATA: D (R) -> m (F), enabled by CK (R)</cl> 
<cl>DATA: D (F) -> mb (F), enabled by CK (R)</cl>
<cl>DATA: m (F) -> mb (R)</cl> 
<cl>DATA: mb (F) -> m (R)</cl>
<cl>ACCESS: CK (R) -> mb (R) - through the feedback loop</cl>
<cl>ACCESS: CK (R) -> m (R) - through the feedback loop</cl>
<cl>SETUP: m (F) -> CK (F)</cl>
<cl>SETUP: mb (F) -> CK (F)</cl>
<cl>HOLD: m (F) -> CK (F) - closing event of the command </cl>
<cl>HOLD: mb (F) -> CK (F)</cl>
</code>

<p>As it is for the D-Latch, the intrinsic setup time is the propagation delay of the inverter between <f>m</f> and <f>mb</f> and <f>m</f> and <f>mb</f> - for <b>Latch</b> nodes <f>m</f> and <f>mb</f> respectively.</p> 

</section>


</section>

<section niv='3'><title>Symmetric Bitcell</title>

<section niv='4'><title>Typical Structure</title>
<imgsize namehtml="Sym_bitcell.gif" namepdf="Sym_bitcell.svg"/>
</section>

<section niv='4'><title>Latch Nodes and Commands</title>
<p>The latch nodes are here <f>m</f> and <f>mb</f>. The <b>Command</b> transistors are the ones which gate is controlled by <b>ck</b>.</p>
</section>

<section niv='4'><title>Timing Arcs</title>
<p>Timing arcs are the following:</p>

<code>
<cl>DATA: D (R) -> m (F), enabled by CK (R)</cl> 
<cl>DATA: D (F) -> mb (F), enabled by CK (R)</cl>
<cl>DATA: m (F) -> mb (R)</cl> 
<cl>DATA: mb (F) -> m (R)</cl>
<cl>ACCESS: CK (R) -> mb (R) - through the feedback loop</cl>
<cl>ACCESS: CK (R) -> m (R) - through th efeedback loop</cl>
<cl>SETUP: m (F) -> CK (F)</cl>
<cl>SETUP: mb (F) -> CK (F)</cl>
<cl>HOLD: m (F) -> CK (F) - closing event of the command </cl>
<cl>HOLD: mb (F) -> CK (F)</cl>
</code>

<p>The following timing arcs are disabled: the NMOS transistors drive only a weak current in the latch node - considering a rising transition on the latch node.</p> 
<code>
<cl>DATA: D (R) -> m (R), enabled by CK (R)</cl> 
<cl>DATA: D (F) -> mb (R), enabled by CK (R)</cl>
</code>
<p>However, the contribution of the current through the NMOS is taken into account when evaluating the delays of the inverters in the loop. These delays are further used for computing intrinsic setup and hold times. &tool; just assumes that transitions on <f>d</f> and <f>db</f> are simultaneous.</p> 

</section>
</section>

<section niv='3'><title>Asymmetric Pulldown </title>
<section niv='4'><title>Typical Structure</title>
<imgsize namehtml="Asym_pulldown.gif" namepdf="Asym_pulldown.svg"/>
</section>



<section niv='4'><title>Latch Nodes and Commands</title>
<p>The latch nodes are here <f>m</f> and <f>mb</f>. The <b>Command</b> transistors are the ones which gate is controlled by <b>ck</b>.</p>
</section>

<section niv='4'><title>Timing Arcs</title>
<p>Timing arcs are the following:</p>

<code>
<cl>DATA: D (R) -> m (F), enabled by CK (R)</cl> 
<cl>DATA: D (F) -> mb (F), enabled by CK (R)</cl>
<cl>DATA: m (F) -> mb (R)</cl> 
<cl>DATA: mb (F) -> m (R)</cl>
<cl>ACCESS: CK (R) -> mb (R) - through the feedback loop</cl>
<cl>ACCESS: CK (R) -> m (R) - through th efeedback loop</cl>
<cl>SETUP: m (F) -> CK (F)</cl>
<cl>SETUP: mb (F) -> CK (F)</cl>
<cl>HOLD: m (F) -> CK (F) </cl>
<cl>HOLD: mb (F) -> CK (F)</cl>
</code>

<p>The following timing arc is disabled: the NMOS transistor drive only a weak current in the latch node <f>m</f> - considering a rising transition on the latch node.</p> 
<code>
<cl>DATA: D (R) -> m (R), enabled by CK (R)</cl> 
</code>
<p>However, the contribution of the current through the NMOS is taken into account when evaluating the delay of the inverter between  <f>mb</f> and <f>m</f>. This delay is further used for computing intrinsic setup and hold times.</p> 

</section>




</section>

</section>

<section niv='2'><title>Dynamic Latches</title>
<p>Dynamic latches are typically tristate nodes followed by a capacitance. In default mode,
tristate nodes are not marked as latches. This behavior can be changed with the <f>yagMarkTristateMemory</f>
configuration variable.</p>
<p>Dynamic latches can also be identified with the INF commands <f>inf_DefineDLatch</f> and <f>inf_DefineNotDLatch</f></p>
</section>


<section niv='2'><title>Special Elements</title>

<section niv='3'><title>Transmission Gates</title>
<p>Transmission gate characterization is natively handled by &tool;, and most of the times it requires no additional
configuration. However, there are some cases where correct characterization of the transmission gates depends on the
functional behavior of the design, and therefore those cases can not be perfectly handled by static tool. The following
diagram illustrates this typical case:</p>
<imgsize namehtml="opc.gif" namepdf="opc.svg"/>

<p>The difficulty here is to properly estimate the amount of capacitance C to be used for the computation of the propagation
delay of the inverter 1. The value of this capacitance depends on the logic levels of P1 and P2 driving the transmission gates,
while circuit is operating. It is then practically impossible for a static tool to determine 
exactly the amount of capacitance to be used, as C can change with different combinations of logic levels on P1 and P2. 
The best thing a static tool can do is to compute min and max capacitances, corresponding to 'all transmission gates closed' and 
'all transmission gates opened'.</p>
<p>However, the combinations of logic levels on signals driving the transmission-gates may be limited, and may obviously
not lead to the worst case situation, e.g. where all the transmission gates are opened. For example in the case of
multiplexers or routing matrices, only one of N transmission gates is opened at a time. &tool; does not provide an 
automatic mechanism to detect those kinds mutual exclusion situations, but provides two variables to control them 
manually:</p>
<p><f>tasPathCapacitanceFactor</f> globally controls the ratio of transmission-gates that can be opened at the same time,
when determining the capacitance to be used to compute maximum propagation delays. Minimum propagation delays are computed
with a ratio of 0.</p>
<p><f>tasSwitchCapacitanceFactor</f> globally controls the ratio of transmission-gates that can be opened at the same time,
when determining the capacitance to be associated with input connectors.</p>
</section>

<section niv='3'><title>Transmission Gate Multiplexers</title>
<p>The detection of multiplexors is done purely algorithmically. The cone partitioning strategy implemented in &tool; perfectly 
fits with the detection and modeling of transmission-gate based multiplexers, provided that the correlations
between the commands can be resolved within the design. The only reason why detection may fail, is because the
schematic of the design itself prevents to identify those correlations, for example when commands are input pins. 
In such a case, correlations (mutual exclusion) should be set externally with INF commands.</p> 
<p>The following diagram shows two situations. In the left-hand design, the mutual exclusion between <f>sel</f> and <f>nsel</f> 
is not ensured by the design. There is no way for the tool to identify inputs and outputs, and it constructs
false current paths. In the right-hand design, the mutual exclusion between
<f>sel</f> and <f>nsel</f> is ensured by the invertor, and therefore the tool correctly models the multiplexer. </p>
<imgsize namehtml="mux.gif" namepdf="mux.svg"/>
<p>To avoid the construction of false current paths in the left-hand design, the following mutual exclusion 
configuration should be set:</p>
<code>
<cl>inf_DefineMutex cmpUP {sel nsel}</cl>
</code>
<p>If the transmission gate toppology is more complex, and setting of mutual exclusion constraints
become too much difficult, another orientation mechanism is available. Let's consider the next design:</p>
<imgsize namehtml="mux2.gif" namepdf="mux2.svg"/>
<p>Here orientation can be done by setting levels on signals <f>i0</f>, <f>i1</f>, <f>s</f> and <f>out</f>.
The transistors are oriented by assuming the current is going from the signals with the higher level to
the signals with the lower level. Levels should be set as follow:</p>
<code>
<cl>inf_DefineDirout i0  3</cl>
<cl>inf_DefineDirout i1  3</cl>
<cl>inf_DefineDirout s   2</cl>
<cl>inf_DefineDirout out 1</cl>
</code>

<p>The default orientation value of signals is <f>-1</f>.</p>

</section>



<section niv='3'><title>Domino Precharge</title>
<p>The following configuration enables the automatic precharge detection algorithm.</p>
<code>
<cl>avt_config yagDetectPrecharge yes</cl>
</code>

<p>However, precharged elements and latches may present very similar structures, and it is not impossible that
the tool mix up between them. In this case, it is more careful to define manually the pre-charged structures.
Example is given for a precharged signal named <f>pre1</f>, within a design named <f>my_design</f>:</p>
<code>
<cl>inf_SetFigureName my_design</cl>
<cl>inf_DefinePrecharge "pre1"</cl>
<cl>inf_DefineDirout "pre1"</cl>
</code>
<p>In any case, the following configuration line should be added to enable &tool; to perform special treatment
on the precharged signals.</p>
<code>
<cl>avt_config tasTreatPrecharge yes</cl>
</code>
</section>
</section>


<section niv='2'><title>Case Analysis</title>
<p>Case analysis, such as Scan Mode analysis or Functional mode analysis, is available in the &tool; platform. It 
is performed by sticking input connectors or internal signals to logical low or logical high values. It is done by adding in the Tcl 
script the SDC command <f>set_case_analysis</f>.</p>
<p>The logical value stuck on the input connector or logical signal is propagated through the design, with regard
to the behavior of the gates it crosses. A report of the stuck signals is available in the <f>.rep</f> file:</p>
<code>
<cl>[WRN 30] Signal 'ram_na3' is stuck at Zero</cl>
<cl>[WRN 31] Signal 'ram_a43r_net6' is stuck at One</cl>
</code>


</section>

<section niv='2'><title>Integrating External Timing Abstractions</title>
<p>The most straightforward way to integrate 3rd party abstractions is to preload them
with <f>avt_LoadFile</f> function. In the following example, the transistor-level description of the sub-circuit <f>mult</f>
is not available. A <f>.lib</f> file is used as substitution.</p>

<code>
<cl>avt_LoadFile charac/mult.lib lib</cl>
<cl>avt_LoadFile cells/*.spi spice</cl>
<cl>avt_LoadFile my_design.spi spice</cl>
<cl>set fig [hitas my_design]</cl>
</code>

<p>It is important that the <f>mult</f> sub-circuit is not among the sub-circuits loaded in Spice format, i.e.
in the <f>my_design.spi</f> file. If the <f>mult</f> sub-circuit has been loaded in Spice format, it should be blackboxed,
using either the BLACKBOX file mechanism or the <f>avt_SetBlackBoxes</f> Tcl function.</p>

<p>The BLACKBOX file mechanism works as follow:</p>

<p>As soon as a BLACKBOX file exists in one the directories reachable from &tool; (i.e. the directories 
specified by the <f>avtLibraryDirs</f> variable), &tool; systematically reads it and blackboxes 
all the sub-circuits it contains. No variable controls the effective blackboxing of the sub-circuits 
the BLACKBOX file contains. The mere presence of the BLACKBOX file presence is a sufficient condition.</p>

<p>If <f>avt_SetBlackBoxes</f> Tcl function is used, the BLACKBOX file mechanism is disabled.</p>

<p>If BLACKBOX file is required, the following line should appear in it:</p>
<code>
<cl>mult</cl>
</code>

<p>In addition, the following line should appear in the script:</p> 
<code>
<cl>avt_config tasTreatBlacboxHierarchically yes</cl>
</code>
</section>

</section>



</chapter>
